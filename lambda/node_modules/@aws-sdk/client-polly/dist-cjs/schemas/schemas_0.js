"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetSpeechSynthesisTask$ = exports.GetLexicon$ = exports.DescribeVoices$ = exports.DeleteLexicon$ = exports.Voice$ = exports.SynthesizeSpeechOutput$ = exports.SynthesizeSpeechInput$ = exports.SynthesisTask$ = exports.StartSpeechSynthesisTaskOutput$ = exports.StartSpeechSynthesisTaskInput$ = exports.PutLexiconOutput$ = exports.PutLexiconInput$ = exports.ListSpeechSynthesisTasksOutput$ = exports.ListSpeechSynthesisTasksInput$ = exports.ListLexiconsOutput$ = exports.ListLexiconsInput$ = exports.LexiconDescription$ = exports.LexiconAttributes$ = exports.Lexicon$ = exports.GetSpeechSynthesisTaskOutput$ = exports.GetSpeechSynthesisTaskInput$ = exports.GetLexiconOutput$ = exports.GetLexiconInput$ = exports.DescribeVoicesOutput$ = exports.DescribeVoicesInput$ = exports.DeleteLexiconOutput$ = exports.DeleteLexiconInput$ = exports.errorTypeRegistries = exports.UnsupportedPlsLanguageException$ = exports.UnsupportedPlsAlphabetException$ = exports.TextLengthExceededException$ = exports.SynthesisTaskNotFoundException$ = exports.SsmlMarksNotSupportedForTextTypeException$ = exports.ServiceFailureException$ = exports.MaxLexiconsNumberExceededException$ = exports.MaxLexemeLengthExceededException$ = exports.MarksNotSupportedForFormatException$ = exports.LexiconSizeExceededException$ = exports.LexiconNotFoundException$ = exports.LanguageNotSupportedException$ = exports.InvalidTaskIdException$ = exports.InvalidSsmlException$ = exports.InvalidSnsTopicArnException$ = exports.InvalidSampleRateException$ = exports.InvalidS3KeyException$ = exports.InvalidS3BucketException$ = exports.InvalidNextTokenException$ = exports.InvalidLexiconException$ = exports.EngineNotSupportedException$ = exports.PollyServiceException$ = void 0;
exports.SynthesizeSpeech$ = exports.StartSpeechSynthesisTask$ = exports.PutLexicon$ = exports.ListSpeechSynthesisTasks$ = exports.ListLexicons$ = void 0;
const _A = "Alphabet";
const _ALC = "AdditionalLanguageCodes";
const _AS = "AudioStream";
const _At = "Attributes";
const _C = "Content";
const _CT = "CreationTime";
const _CT_ = "Content-Type";
const _CTo = "ContentType";
const _DL = "DeleteLexicon";
const _DLI = "DeleteLexiconInput";
const _DLO = "DeleteLexiconOutput";
const _DV = "DescribeVoices";
const _DVI = "DescribeVoicesInput";
const _DVO = "DescribeVoicesOutput";
const _E = "Engine";
const _ENSE = "EngineNotSupportedException";
const _G = "Gender";
const _GL = "GetLexicon";
const _GLI = "GetLexiconInput";
const _GLO = "GetLexiconOutput";
const _GSST = "GetSpeechSynthesisTask";
const _GSSTI = "GetSpeechSynthesisTaskInput";
const _GSSTO = "GetSpeechSynthesisTaskOutput";
const _I = "Id";
const _IALC = "IncludeAdditionalLanguageCodes";
const _ILE = "InvalidLexiconException";
const _INTE = "InvalidNextTokenException";
const _ISBE = "InvalidS3BucketException";
const _ISE = "InvalidSsmlException";
const _ISKE = "InvalidS3KeyException";
const _ISRE = "InvalidSampleRateException";
const _ISTAE = "InvalidSnsTopicArnException";
const _ITIE = "InvalidTaskIdException";
const _L = "Lexicon";
const _LA = "LexiconAttributes";
const _LAe = "LexiconArn";
const _LC = "LexiconContent";
const _LCa = "LanguageCode";
const _LCe = "LexemesCount";
const _LD = "LexiconDescription";
const _LDL = "LexiconDescriptionList";
const _LL = "ListLexicons";
const _LLI = "ListLexiconsInput";
const _LLO = "ListLexiconsOutput";
const _LM = "LastModified";
const _LN = "LexiconNames";
const _LNFE = "LexiconNotFoundException";
const _LNSE = "LanguageNotSupportedException";
const _LNa = "LanguageName";
const _LSEE = "LexiconSizeExceededException";
const _LSST = "ListSpeechSynthesisTasks";
const _LSSTI = "ListSpeechSynthesisTasksInput";
const _LSSTO = "ListSpeechSynthesisTasksOutput";
const _Le = "Lexicons";
const _MLLEE = "MaxLexemeLengthExceededException";
const _MLNEE = "MaxLexiconsNumberExceededException";
const _MNSFFE = "MarksNotSupportedForFormatException";
const _MR = "MaxResults";
const _N = "Name";
const _NT = "NextToken";
const _OF = "OutputFormat";
const _OSBN = "OutputS3BucketName";
const _OSKP = "OutputS3KeyPrefix";
const _OU = "OutputUri";
const _PL = "PutLexicon";
const _PLI = "PutLexiconInput";
const _PLO = "PutLexiconOutput";
const _RC = "RequestCharacters";
const _S = "Size";
const _SE = "SupportedEngines";
const _SFE = "ServiceFailureException";
const _SMNSFTTE = "SsmlMarksNotSupportedForTextTypeException";
const _SMT = "SpeechMarkTypes";
const _SR = "SampleRate";
const _SS = "SynthesizeSpeech";
const _SSI = "SynthesizeSpeechInput";
const _SSO = "SynthesizeSpeechOutput";
const _SSST = "StartSpeechSynthesisTask";
const _SSSTI = "StartSpeechSynthesisTaskInput";
const _SSSTO = "StartSpeechSynthesisTaskOutput";
const _ST = "SynthesisTask";
const _STA = "SnsTopicArn";
const _STNFE = "SynthesisTaskNotFoundException";
const _STy = "SynthesisTasks";
const _St = "Status";
const _T = "Text";
const _TI = "TaskId";
const _TLEE = "TextLengthExceededException";
const _TS = "TaskStatus";
const _TSR = "TaskStatusReason";
const _TT = "TextType";
const _UPAE = "UnsupportedPlsAlphabetException";
const _UPLE = "UnsupportedPlsLanguageException";
const _V = "Voices";
const _VI = "VoiceId";
const _VL = "VoiceList";
const _Vo = "Voice";
const _c = "client";
const _e = "error";
const _h = "http";
const _hE = "httpError";
const _hH = "httpHeader";
const _hQ = "httpQuery";
const _m = "message";
const _s = "smithy.ts.sdk.synthetic.com.amazonaws.polly";
const _se = "server";
const _st = "streaming";
const _xaR = "x-amzn-RequestCharacters";
const n0 = "com.amazonaws.polly";
const schema_1 = require("@smithy/core/schema");
const errors_1 = require("../models/errors");
const PollyServiceException_1 = require("../models/PollyServiceException");
const _s_registry = schema_1.TypeRegistry.for(_s);
exports.PollyServiceException$ = [-3, _s, "PollyServiceException", 0, [], []];
_s_registry.registerError(exports.PollyServiceException$, PollyServiceException_1.PollyServiceException);
const n0_registry = schema_1.TypeRegistry.for(n0);
exports.EngineNotSupportedException$ = [-3, n0, _ENSE,
    { [_e]: _c, [_hE]: 400 },
    [_m],
    [0]
];
n0_registry.registerError(exports.EngineNotSupportedException$, errors_1.EngineNotSupportedException);
exports.InvalidLexiconException$ = [-3, n0, _ILE,
    { [_e]: _c, [_hE]: 400 },
    [_m],
    [0]
];
n0_registry.registerError(exports.InvalidLexiconException$, errors_1.InvalidLexiconException);
exports.InvalidNextTokenException$ = [-3, n0, _INTE,
    { [_e]: _c, [_hE]: 400 },
    [_m],
    [0]
];
n0_registry.registerError(exports.InvalidNextTokenException$, errors_1.InvalidNextTokenException);
exports.InvalidS3BucketException$ = [-3, n0, _ISBE,
    { [_e]: _c, [_hE]: 400 },
    [_m],
    [0]
];
n0_registry.registerError(exports.InvalidS3BucketException$, errors_1.InvalidS3BucketException);
exports.InvalidS3KeyException$ = [-3, n0, _ISKE,
    { [_e]: _c, [_hE]: 400 },
    [_m],
    [0]
];
n0_registry.registerError(exports.InvalidS3KeyException$, errors_1.InvalidS3KeyException);
exports.InvalidSampleRateException$ = [-3, n0, _ISRE,
    { [_e]: _c, [_hE]: 400 },
    [_m],
    [0]
];
n0_registry.registerError(exports.InvalidSampleRateException$, errors_1.InvalidSampleRateException);
exports.InvalidSnsTopicArnException$ = [-3, n0, _ISTAE,
    { [_e]: _c, [_hE]: 400 },
    [_m],
    [0]
];
n0_registry.registerError(exports.InvalidSnsTopicArnException$, errors_1.InvalidSnsTopicArnException);
exports.InvalidSsmlException$ = [-3, n0, _ISE,
    { [_e]: _c, [_hE]: 400 },
    [_m],
    [0]
];
n0_registry.registerError(exports.InvalidSsmlException$, errors_1.InvalidSsmlException);
exports.InvalidTaskIdException$ = [-3, n0, _ITIE,
    { [_e]: _c, [_hE]: 400 },
    [_m],
    [0]
];
n0_registry.registerError(exports.InvalidTaskIdException$, errors_1.InvalidTaskIdException);
exports.LanguageNotSupportedException$ = [-3, n0, _LNSE,
    { [_e]: _c, [_hE]: 400 },
    [_m],
    [0]
];
n0_registry.registerError(exports.LanguageNotSupportedException$, errors_1.LanguageNotSupportedException);
exports.LexiconNotFoundException$ = [-3, n0, _LNFE,
    { [_e]: _c, [_hE]: 404 },
    [_m],
    [0]
];
n0_registry.registerError(exports.LexiconNotFoundException$, errors_1.LexiconNotFoundException);
exports.LexiconSizeExceededException$ = [-3, n0, _LSEE,
    { [_e]: _c, [_hE]: 400 },
    [_m],
    [0]
];
n0_registry.registerError(exports.LexiconSizeExceededException$, errors_1.LexiconSizeExceededException);
exports.MarksNotSupportedForFormatException$ = [-3, n0, _MNSFFE,
    { [_e]: _c, [_hE]: 400 },
    [_m],
    [0]
];
n0_registry.registerError(exports.MarksNotSupportedForFormatException$, errors_1.MarksNotSupportedForFormatException);
exports.MaxLexemeLengthExceededException$ = [-3, n0, _MLLEE,
    { [_e]: _c, [_hE]: 400 },
    [_m],
    [0]
];
n0_registry.registerError(exports.MaxLexemeLengthExceededException$, errors_1.MaxLexemeLengthExceededException);
exports.MaxLexiconsNumberExceededException$ = [-3, n0, _MLNEE,
    { [_e]: _c, [_hE]: 400 },
    [_m],
    [0]
];
n0_registry.registerError(exports.MaxLexiconsNumberExceededException$, errors_1.MaxLexiconsNumberExceededException);
exports.ServiceFailureException$ = [-3, n0, _SFE,
    { [_e]: _se, [_hE]: 500 },
    [_m],
    [0]
];
n0_registry.registerError(exports.ServiceFailureException$, errors_1.ServiceFailureException);
exports.SsmlMarksNotSupportedForTextTypeException$ = [-3, n0, _SMNSFTTE,
    { [_e]: _c, [_hE]: 400 },
    [_m],
    [0]
];
n0_registry.registerError(exports.SsmlMarksNotSupportedForTextTypeException$, errors_1.SsmlMarksNotSupportedForTextTypeException);
exports.SynthesisTaskNotFoundException$ = [-3, n0, _STNFE,
    { [_e]: _c, [_hE]: 400 },
    [_m],
    [0]
];
n0_registry.registerError(exports.SynthesisTaskNotFoundException$, errors_1.SynthesisTaskNotFoundException);
exports.TextLengthExceededException$ = [-3, n0, _TLEE,
    { [_e]: _c, [_hE]: 400 },
    [_m],
    [0]
];
n0_registry.registerError(exports.TextLengthExceededException$, errors_1.TextLengthExceededException);
exports.UnsupportedPlsAlphabetException$ = [-3, n0, _UPAE,
    { [_e]: _c, [_hE]: 400 },
    [_m],
    [0]
];
n0_registry.registerError(exports.UnsupportedPlsAlphabetException$, errors_1.UnsupportedPlsAlphabetException);
exports.UnsupportedPlsLanguageException$ = [-3, n0, _UPLE,
    { [_e]: _c, [_hE]: 400 },
    [_m],
    [0]
];
n0_registry.registerError(exports.UnsupportedPlsLanguageException$, errors_1.UnsupportedPlsLanguageException);
exports.errorTypeRegistries = [
    _s_registry,
    n0_registry,
];
var AudioStream = [0, n0, _AS, { [_st]: 1 }, 42];
var LexiconContent = [0, n0, _LC, 8, 0];
exports.DeleteLexiconInput$ = [3, n0, _DLI,
    0,
    [_N],
    [[0, 1]], 1
];
exports.DeleteLexiconOutput$ = [3, n0, _DLO,
    0,
    [],
    []
];
exports.DescribeVoicesInput$ = [3, n0, _DVI,
    0,
    [_E, _LCa, _IALC, _NT],
    [[0, { [_hQ]: _E }], [0, { [_hQ]: _LCa }], [2, { [_hQ]: _IALC }], [0, { [_hQ]: _NT }]]
];
exports.DescribeVoicesOutput$ = [3, n0, _DVO,
    0,
    [_V, _NT],
    [() => VoiceList, 0]
];
exports.GetLexiconInput$ = [3, n0, _GLI,
    0,
    [_N],
    [[0, 1]], 1
];
exports.GetLexiconOutput$ = [3, n0, _GLO,
    0,
    [_L, _LA],
    [[() => exports.Lexicon$, 0], () => exports.LexiconAttributes$]
];
exports.GetSpeechSynthesisTaskInput$ = [3, n0, _GSSTI,
    0,
    [_TI],
    [[0, 1]], 1
];
exports.GetSpeechSynthesisTaskOutput$ = [3, n0, _GSSTO,
    0,
    [_ST],
    [() => exports.SynthesisTask$]
];
exports.Lexicon$ = [3, n0, _L,
    0,
    [_C, _N],
    [[() => LexiconContent, 0], 0]
];
exports.LexiconAttributes$ = [3, n0, _LA,
    0,
    [_A, _LCa, _LM, _LAe, _LCe, _S],
    [0, 0, 4, 0, 1, 1]
];
exports.LexiconDescription$ = [3, n0, _LD,
    0,
    [_N, _At],
    [0, () => exports.LexiconAttributes$]
];
exports.ListLexiconsInput$ = [3, n0, _LLI,
    0,
    [_NT],
    [[0, { [_hQ]: _NT }]]
];
exports.ListLexiconsOutput$ = [3, n0, _LLO,
    0,
    [_Le, _NT],
    [() => LexiconDescriptionList, 0]
];
exports.ListSpeechSynthesisTasksInput$ = [3, n0, _LSSTI,
    0,
    [_MR, _NT, _St],
    [[1, { [_hQ]: _MR }], [0, { [_hQ]: _NT }], [0, { [_hQ]: _St }]]
];
exports.ListSpeechSynthesisTasksOutput$ = [3, n0, _LSSTO,
    0,
    [_NT, _STy],
    [0, () => SynthesisTasks]
];
exports.PutLexiconInput$ = [3, n0, _PLI,
    0,
    [_N, _C],
    [[0, 1], [() => LexiconContent, 0]], 2
];
exports.PutLexiconOutput$ = [3, n0, _PLO,
    0,
    [],
    []
];
exports.StartSpeechSynthesisTaskInput$ = [3, n0, _SSSTI,
    0,
    [_OF, _OSBN, _T, _VI, _E, _LCa, _LN, _OSKP, _SR, _STA, _SMT, _TT],
    [0, 0, 0, 0, 0, 0, 64 | 0, 0, 0, 0, 64 | 0, 0], 4
];
exports.StartSpeechSynthesisTaskOutput$ = [3, n0, _SSSTO,
    0,
    [_ST],
    [() => exports.SynthesisTask$]
];
exports.SynthesisTask$ = [3, n0, _ST,
    0,
    [_E, _TI, _TS, _TSR, _OU, _CT, _RC, _STA, _LN, _OF, _SR, _SMT, _TT, _VI, _LCa],
    [0, 0, 0, 0, 0, 4, 1, 0, 64 | 0, 0, 0, 64 | 0, 0, 0, 0]
];
exports.SynthesizeSpeechInput$ = [3, n0, _SSI,
    0,
    [_OF, _T, _VI, _E, _LCa, _LN, _SR, _SMT, _TT],
    [0, 0, 0, 0, 0, 64 | 0, 0, 64 | 0, 0], 3
];
exports.SynthesizeSpeechOutput$ = [3, n0, _SSO,
    0,
    [_AS, _CTo, _RC],
    [[() => AudioStream, 16], [0, { [_hH]: _CT_ }], [1, { [_hH]: _xaR }]]
];
exports.Voice$ = [3, n0, _Vo,
    0,
    [_G, _I, _LCa, _LNa, _N, _ALC, _SE],
    [0, 0, 0, 0, 0, 64 | 0, 64 | 0]
];
var EngineList = 64 | 0;
var LanguageCodeList = 64 | 0;
var LexiconDescriptionList = [1, n0, _LDL,
    0, () => exports.LexiconDescription$
];
var LexiconNameList = 64 | 0;
var SpeechMarkTypeList = 64 | 0;
var SynthesisTasks = [1, n0, _STy,
    0, () => exports.SynthesisTask$
];
var VoiceList = [1, n0, _VL,
    0, () => exports.Voice$
];
exports.DeleteLexicon$ = [9, n0, _DL,
    { [_h]: ["DELETE", "/v1/lexicons/{Name}", 200] }, () => exports.DeleteLexiconInput$, () => exports.DeleteLexiconOutput$
];
exports.DescribeVoices$ = [9, n0, _DV,
    { [_h]: ["GET", "/v1/voices", 200] }, () => exports.DescribeVoicesInput$, () => exports.DescribeVoicesOutput$
];
exports.GetLexicon$ = [9, n0, _GL,
    { [_h]: ["GET", "/v1/lexicons/{Name}", 200] }, () => exports.GetLexiconInput$, () => exports.GetLexiconOutput$
];
exports.GetSpeechSynthesisTask$ = [9, n0, _GSST,
    { [_h]: ["GET", "/v1/synthesisTasks/{TaskId}", 200] }, () => exports.GetSpeechSynthesisTaskInput$, () => exports.GetSpeechSynthesisTaskOutput$
];
exports.ListLexicons$ = [9, n0, _LL,
    { [_h]: ["GET", "/v1/lexicons", 200] }, () => exports.ListLexiconsInput$, () => exports.ListLexiconsOutput$
];
exports.ListSpeechSynthesisTasks$ = [9, n0, _LSST,
    { [_h]: ["GET", "/v1/synthesisTasks", 200] }, () => exports.ListSpeechSynthesisTasksInput$, () => exports.ListSpeechSynthesisTasksOutput$
];
exports.PutLexicon$ = [9, n0, _PL,
    { [_h]: ["PUT", "/v1/lexicons/{Name}", 200] }, () => exports.PutLexiconInput$, () => exports.PutLexiconOutput$
];
exports.StartSpeechSynthesisTask$ = [9, n0, _SSST,
    { [_h]: ["POST", "/v1/synthesisTasks", 200] }, () => exports.StartSpeechSynthesisTaskInput$, () => exports.StartSpeechSynthesisTaskOutput$
];
exports.SynthesizeSpeech$ = [9, n0, _SS,
    { [_h]: ["POST", "/v1/speech", 200] }, () => exports.SynthesizeSpeechInput$, () => exports.SynthesizeSpeechOutput$
];
